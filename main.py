# -*- coding: utf-8 -*-
"""Trabalho do Grau B - Redes de Computadores - Breno Santos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17ANB0ldigDLQg1NotNrn9BhNLui7sAYj
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from math import erfc

# 1. Converter ASCII para binário
def texto_para_bits(texto: str) -> np.ndarray:
    bytes_array = np.frombuffer(texto.encode('utf-8'), dtype=np.uint8)
    bits = np.unpackbits(bytes_array)

    return bits

# 2. Codificadores de canal
def manchester(bits: np.ndarray) -> np.ndarray:
    encoded = []
    for bit in bits:
        if bit == 0:
            encoded.extend([1, 0])
        else:
            encoded.extend([0, 1])

    return np.array(encoded)

def ami_bipolar(bits: np.ndarray) -> np.ndarray:
    encoded = []
    level = 1
    for bit in bits:
        if bit == 0:
            encoded.append(0)
        else:
            encoded.append(level)
            level = -level

    return np.array(encoded)

def nrz(bits: np.ndarray) -> np.ndarray:
    return bits * 2 - 1

def rz(bits: np.ndarray) -> np.ndarray:
    encoded = []
    for bit in bits:
        if bit == 1:
            encoded.extend([1, 0]) # Pulso no símbolo
        else:
            encoded.extend([0, 0]) # Sem pulso

    return np.array(encoded)

# 3. Modulação
def bpsk_modulate(bits: np.ndarray) -> np.ndarray:
    return 2*bits - 1

def qpsk_modulate(bits: np.ndarray) -> np.ndarray:
    bits = bits.reshape(-1, 2)
    symbols = 2*bits[:, 0] + bits[:, 1]

    return symbols

def ps8_modulate(bits: np.ndarray) -> np.ndarray:
    if len(bits) % 3 != 0:
        bits = np.concatenate([bits, np.zeros(3 - len(bits) % 3)])
    bits = bits.reshape(-1, 3)
    symbols = 2*bits[:, 0] + 2*bits[:, 1] + bits[:, 2]

    return symbols * np.pi / 4 # Converte para ângulos de fase

def qam16_modulate(bits: np.ndarray) -> np.ndarray:
    if len(bits) % 4 != 0:
        bits = np.concatenate([bits, np.zeros(4 - len(bits) % 4)])
    bits = bits.reshape(-1, 4)
    symbols = 2*bits[:, 0] + bits[:, 1]
    in_phase = 2*symbols - 3 # Pontos de constelação
    symbols = 2*bits[:, 2] + bits[:, 3]
    quadrature = 2*symbols - 3

    return in_phase + 1j*quadrature # Constelação 16-QAM

# 4. Adição de ruído
def add_awgn_noise(signal: np.ndarray, snr_db: float) -> np.ndarray:
    snr = 10**(snr_db / 10)
    power_signal = np.mean(np.abs(signal)**2)
    power_noise = power_signal / snr
    noise = np.sqrt(power_noise / 2) * np.random.randn(len(signal))

    return signal + noise

def add_impulse_noise(signal: np.ndarray, noise_probability: float) -> np.ndarray:
    noisy_signal = signal.copy()
    for i in range(len(signal)):
        if np.random.rand() < noise_probability:
            noisy_signal[i] = np.random.choice([-1, 1]) # Ruído aleatório

    return noisy_signal

def add_rayleigh_noise(signal: np.ndarray) -> np.ndarray:
    noise = np.random.rayleigh(scale=1, size=len(signal))

    return signal + noise

# 5. Demodulação
def bpsk_demodulate(signal: np.ndarray) -> np.ndarray:
    return (signal > 0).astype(int)

def qpsk_demodulate(symbols: np.ndarray) -> np.ndarray:
    return np.array([int(symbol < 0) for symbol in symbols])

def ps8_demodulate(symbols: np.ndarray) -> np.ndarray:
    decoded_bits = np.array([int(symbol / (np.pi / 4)) for symbol in symbols])
    decoded_bits = decoded_bits.flatten()

    return decoded_bits

def qam16_demodulate(symbols: np.ndarray) -> np.ndarray:
    in_phase = np.round(symbols.real / 2)
    quadrature = np.round(symbols.imag / 2)
    decoded_bits = np.array([int(i) for i in np.concatenate([in_phase, quadrature])])

    return decoded_bits

# 6. Cálculo da Taxa de Erro de Bit (BER)
def calculate_ber(original_bits: np.ndarray, decoded_bits: np.ndarray) -> float:
    if len(decoded_bits) > len(original_bits):
        decoded_bits = decoded_bits[:len(original_bits)]
    elif len(decoded_bits) < len(original_bits):
        decoded_bits = np.concatenate([decoded_bits, np.zeros(len(original_bits) - len(decoded_bits))])

    return np.sum(original_bits != decoded_bits) / len(original_bits)

# 7. Simulação e comparação de desempenho
def simulate_system(message: str, snr_range: np.ndarray, noise_type: str = 'AWGN', modulation_type: str = 'BPSK', codificador_type: str = 'Manchester') -> np.ndarray:
    bits = texto_para_bits(message)

    if codificador_type == 'Manchester':
        encoded_bits = manchester(bits)
    elif codificador_type == 'AMI':
        encoded_bits = ami_bipolar(bits)
    elif codificador_type == 'NRZ':
        encoded_bits = nrz(bits)
    elif codificador_type == 'RZ':
        encoded_bits = rz(bits)

    if modulation_type == 'BPSK':
        modulated_signal = bpsk_modulate(encoded_bits)
    elif modulation_type == 'QPSK':
        modulated_signal = qpsk_modulate(encoded_bits)
    elif modulation_type == '8PSK':
        modulated_signal = ps8_modulate(encoded_bits)
    elif modulation_type == '16QAM':
        modulated_signal = qam16_modulate(encoded_bits)

    ber_results = []

    for snr_db in snr_range:
        if noise_type == 'AWGN':
            noisy_signal = add_awgn_noise(modulated_signal, snr_db)
        elif noise_type == 'Impulse':
            noisy_signal = add_impulse_noise(modulated_signal, noise_probability=0.1)
        elif noise_type == 'Rayleigh':
            noisy_signal = add_rayleigh_noise(modulated_signal)

        if modulation_type == 'BPSK':
            demodulated_bits = bpsk_demodulate(noisy_signal)
        elif modulation_type == 'QPSK':
            demodulated_bits = qpsk_demodulate(noisy_signal)
        elif modulation_type == '8PSK':
            demodulated_bits = ps8_demodulate(noisy_signal)
        elif modulation_type == '16QAM':
            demodulated_bits = qam16_demodulate(noisy_signal)

        ber = calculate_ber(bits, demodulated_bits[:len(bits)])
        ber_results.append(ber)

    return np.array(ber_results)

# 8. Geração dos gráficos de comparação
def plot_multiple_comparisons(snr_range: np.ndarray, ber_results: dict):
    plt.figure(figsize=(12, 8))

    for label, result in ber_results.items():
        plt.semilogy(snr_range, result, label=label, marker='o')

    plt.title("Comparação de BER entre diferentes esquemas de modulação, codificação e ruído")
    plt.xlabel("SNR (dB)")
    plt.ylabel("Taxa de Erro de Bit (BER)")
    plt.grid(True)
    plt.legend()
    plt.show()

# 9. Executar simulações e gerar gráficos
snr_range = np.arange(0, 21, 2) # Intervalo de SNR de 0 a 20 dB
message = "Este é um teste de comunicação digital!"

# Simulações para diferentes combinações
ber_bpsk_manchester_awgn = simulate_system(message, snr_range, modulation_type='BPSK', codificador_type='Manchester', noise_type='AWGN')
ber_qpsk_manchester_awgn = simulate_system(message, snr_range, modulation_type='QPSK', codificador_type='Manchester', noise_type='AWGN')
ber_ps8_manchester_awgn = simulate_system(message, snr_range, modulation_type='8PSK', codificador_type='Manchester', noise_type='AWGN')
ber_qam16_manchester_awgn = simulate_system(message, snr_range, modulation_type='16QAM', codificador_type='Manchester', noise_type='AWGN')

# Simulações com ruído impulsivo
ber_bpsk_manchester_impulse = simulate_system(message, snr_range, modulation_type='BPSK', codificador_type='Manchester', noise_type='Impulse')
ber_qpsk_manchester_impulse = simulate_system(message, snr_range, modulation_type='QPSK', codificador_type='Manchester', noise_type='Impulse')

# Simulações com ruído Rayleigh
ber_bpsk_manchester_rayleigh = simulate_system(message, snr_range, modulation_type='BPSK', codificador_type='Manchester', noise_type='Rayleigh')

# Gráfico de comparação para múltiplas combinações
ber_results = {
    "BPSK + Manchester + AWGN": ber_bpsk_manchester_awgn,
    "QPSK + Manchester + AWGN": ber_qpsk_manchester_awgn,
    "8PSK + Manchester + AWGN": ber_ps8_manchester_awgn,
    "16QAM + Manchester + AWGN": ber_qam16_manchester_awgn,
    "BPSK + Manchester + Impulse": ber_bpsk_manchester_impulse,
    "QPSK + Manchester + Impulse": ber_qpsk_manchester_impulse,
    "BPSK + Manchester + Rayleigh": ber_bpsk_manchester_rayleigh,
}

print("\nGráfico de comparação para múltiplas combinações:\n")
plot_multiple_comparisons(snr_range, ber_results)

def plot_ber_comparison_codificacao(snr_range: np.ndarray, ber_results: dict):
    """Gera gráfico comparando diferentes codificações para a mesma modulação e tipo de ruído"""
    plt.figure(figsize=(12, 8))
    for label, result in ber_results.items():
        plt.semilogy(snr_range, result, label=label, marker='o')

    plt.title("Comparação de BER entre diferentes codificações (BPSK + AWGN)")
    plt.xlabel("SNR (dB)")
    plt.ylabel("Taxa de Erro de Bit (BER)")
    plt.grid(True)
    plt.legend()
    plt.show()

def plot_ber_comparison_ruido(snr_range: np.ndarray, ber_results: dict):
    """Gera gráfico comparando o efeito de diferentes tipos de ruído para a mesma modulação e codificação"""
    plt.figure(figsize=(12, 8))
    for label, result in ber_results.items():
        plt.semilogy(snr_range, result, label=label, marker='x')

    plt.title("Comparação de BER entre diferentes tipos de ruído (BPSK + Manchester)")
    plt.xlabel("SNR (dB)")
    plt.ylabel("Taxa de Erro de Bit (BER)")
    plt.grid(True)
    plt.legend()
    plt.show()

def plot_ber_comparison_modulacao(snr_range: np.ndarray, ber_results: dict):
    """Gera gráfico comparando diferentes modulações para a mesma codificação e tipo de ruído"""
    plt.figure(figsize=(12, 8))
    for label, result in ber_results.items():
        plt.semilogy(snr_range, result, label=label, marker='o')

    plt.title("Comparação de BER entre diferentes modulações (Manchester + AWGN)")
    plt.xlabel("SNR (dB)")
    plt.ylabel("Taxa de Erro de Bit (BER)")
    plt.grid(True)
    plt.legend()
    plt.show()

# 11. Simulações adicionais:

# Simulação de BPSK com diferentes codificações
ber_bpsk_manchester_awgn = simulate_system("Teste de comunicação BPSK", snr_range, modulation_type='BPSK', codificador_type='Manchester', noise_type='AWGN')
ber_bpsk_ami_awgn = simulate_system("Teste de comunicação BPSK", snr_range, modulation_type='BPSK', codificador_type='AMI', noise_type='AWGN')
ber_bpsk_nrz_awgn = simulate_system("Teste de comunicação BPSK", snr_range, modulation_type='BPSK', codificador_type='NRZ', noise_type='AWGN')
ber_bpsk_rz_awgn = simulate_system("Teste de comunicação BPSK", snr_range, modulation_type='BPSK', codificador_type='RZ', noise_type='AWGN')

# Simulação de BPSK com diferentes tipos de ruído
ber_bpsk_awgn = simulate_system("Teste de comunicação BPSK", snr_range, modulation_type='BPSK', codificador_type='Manchester', noise_type='AWGN')
ber_bpsk_impulse = simulate_system("Teste de comunicação BPSK", snr_range, modulation_type='BPSK', codificador_type='Manchester', noise_type='Impulse')
ber_bpsk_rayleigh = simulate_system("Teste de comunicação BPSK", snr_range, modulation_type='BPSK', codificador_type='Manchester', noise_type='Rayleigh')

# Simulação de modulações com Manchester e AWGN
ber_bpsk_manchester_awgn = simulate_system("Teste de comunicação", snr_range, modulation_type='BPSK', codificador_type='Manchester', noise_type='AWGN')
ber_qpsk_manchester_awgn = simulate_system("Teste de comunicação", snr_range, modulation_type='QPSK', codificador_type='Manchester', noise_type='AWGN')
ber_ps8_manchester_awgn = simulate_system("Teste de comunicação", snr_range, modulation_type='8PSK', codificador_type='Manchester', noise_type='AWGN')
ber_qam16_manchester_awgn = simulate_system("Teste de comunicação", snr_range, modulation_type='16QAM', codificador_type='Manchester', noise_type='AWGN')

# Gráfico comparando diferentes codificações para BPSK com AWGN
ber_results_codificacao = {
    "Manchester": ber_bpsk_manchester_awgn,
    "AMI": ber_bpsk_ami_awgn,
    "NRZ": ber_bpsk_nrz_awgn,
    "RZ": ber_bpsk_rz_awgn
}
print("\nGráfico comparando diferentes codificações para BPSK com AWGN:\n")
plot_ber_comparison_codificacao(snr_range, ber_results_codificacao)

# Gráfico comparando o efeito de diferentes tipos de ruído para BPSK com Manchester
ber_results_ruido = {
    "AWGN": ber_bpsk_awgn,
    "Impulsivo": ber_bpsk_impulse,
    "Rayleigh": ber_bpsk_rayleigh
}
print("\nGráfico comparando o efeito de diferentes tipos de ruído para BPSK com Manchester:\n")
plot_ber_comparison_ruido(snr_range, ber_results_ruido)

# Gráfico comparando diferentes modulações com Manchester e AWGN
ber_results_modulacao = {
    "BPSK": ber_bpsk_manchester_awgn,
    "QPSK": ber_qpsk_manchester_awgn,
    "8PSK": ber_ps8_manchester_awgn,
    "16-QAM": ber_qam16_manchester_awgn
}
print("\nGráfico comparando diferentes modulações com Manchester e AWGN:\n")
plot_ber_comparison_modulacao(snr_range, ber_results_modulacao)

# 10. Simulações para todas as combinações de codificações, modulações e ruídos
def generate_all_comparisons(snr_range: np.ndarray, message: str):
    codificadores = ['Manchester', 'AMI', 'NRZ', 'RZ']
    modulações = ['BPSK', 'QPSK', '8PSK', '16QAM']
    ruídos = ['AWGN', 'Impulse', 'Rayleigh']

    # Resultados de BER para armazenar todas as combinações
    ber_results = {}

    for codificador in codificadores:
        for modulacao in modulações:
            for ruido in ruídos:
                key = f"{modulacao} + {codificador} + {ruido}"
                ber_results[key] = simulate_system(message, snr_range, noise_type=ruido, modulation_type=modulacao, codificador_type=codificador)

    # Gerar gráficos separados para cada combinação
    for key, result in ber_results.items():
        plot_comparison(snr_range, result, key)

# 11. Função para gerar um gráfico separado por combinação
def plot_comparison(snr_range: np.ndarray, ber_result: np.ndarray, key: str):
    plt.figure(figsize=(12, 8))
    plt.semilogy(snr_range, ber_result, marker='o')
    plt.title(f"Comparação de BER - {key}")
    plt.xlabel("SNR (dB)")
    plt.ylabel("Taxa de Erro de Bit (BER)")
    plt.grid(True)
    plt.show()

# 12. Executar as simulações para todas as combinações
generate_all_comparisons(snr_range, message)